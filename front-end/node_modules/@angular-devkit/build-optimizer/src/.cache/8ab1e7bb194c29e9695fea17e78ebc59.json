{"remainingRequest":"/home/skan/program/gitLab/materialDidactico/front-end/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--8-1!/home/skan/program/gitLab/materialDidactico/front-end/node_modules/angular-notifier/esm5/src/components/notifier-container.component.js","dependencies":[{"path":"/home/skan/program/gitLab/materialDidactico/front-end/node_modules/angular-notifier/esm5/src/components/notifier-container.component.js","mtime":499162500000},{"path":"/home/skan/program/gitLab/materialDidactico/front-end/node_modules/cache-loader/dist/cjs.js","mtime":1540859967560},{"path":"/home/skan/program/gitLab/materialDidactico/front-end/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1528256844000}],"contextDependencies":[],"result":["/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nimport { ChangeDetectionStrategy, ChangeDetectorRef, Component } from '@angular/core';\nimport { NotifierNotification } from './../models/notifier-notification.model';\nimport { NotifierQueueService } from './../services/notifier-queue.service';\nimport { NotifierService } from './../services/notifier.service';\n/**\n * Notifier container component\n * ----------------------------\n * This component acts as a wrapper for all notification components; consequently, it is responsible for creating a new notification\n * component and removing an existing notification component. Being more precicely, it also handles side effects of those actions, such as\n * shifting or even completely removing other notifications as well. Overall, this components handles actions coming from the queue service\n * by subscribing to its action stream.\n *\n * Technical sidenote:\n * This component has to be used somewhere in an application to work; it will not inject and create itself automatically, primarily in order\n * to not break the Angular AoT compilation. Moreover, this component (and also the notification components) set their change detection\n * strategy onPush, which means that we handle change detection manually in order to get the best performance. (#perfmatters)\n */\nvar NotifierContainerComponent = /** @class */ /*@__PURE__*/ (function () {\n    function NotifierContainerComponent(changeDetector, notifierQueueService, notifierService) {\n        this.changeDetector = changeDetector;\n        this.queueService = notifierQueueService;\n        this.config = notifierService.getConfig();\n        this.notifications = [];\n    }\n    /**\n     * Component initialization lifecycle hook, connects this component to the action queue, and then handles incoming actions\n     * @return {?}\n     */\n    NotifierContainerComponent.prototype.ngOnInit = /**\n     * Component initialization lifecycle hook, connects this component to the action queue, and then handles incoming actions\n     * @return {?}\n     */\n        function () {\n            var _this = this;\n            this.queueServiceSubscription = this.queueService.actionStream.subscribe(function (action) {\n                _this.handleAction(action).then(function () {\n                    _this.queueService.continue();\n                });\n            });\n        };\n    /**\n     * Component destroyment lifecycle hook, cleans up the observable subsciption\n     * @return {?}\n     */\n    NotifierContainerComponent.prototype.ngOnDestroy = /**\n     * Component destroyment lifecycle hook, cleans up the observable subsciption\n     * @return {?}\n     */\n        function () {\n            if (this.queueServiceSubscription) {\n                this.queueServiceSubscription.unsubscribe();\n            }\n        };\n    /**\n     * Notification identifier, used as the ngFor trackby function\n     *\n     * @param {?} index        Index\n     * @param {?} notification Notifier notification\n     * @return {?} Notification ID as the unique identnfier\n     */\n    NotifierContainerComponent.prototype.identifyNotification = /**\n     * Notification identifier, used as the ngFor trackby function\n     *\n     * @param {?} index        Index\n     * @param {?} notification Notifier notification\n     * @return {?} Notification ID as the unique identnfier\n     */\n        function (index, notification) {\n            return notification.id;\n        };\n    /**\n     * Event handler, handles clicks on notification dismiss buttons\n     *\n     * @param {?} notificationId ID of the notification to dismiss\n     * @return {?}\n     */\n    NotifierContainerComponent.prototype.onNotificationDismiss = /**\n     * Event handler, handles clicks on notification dismiss buttons\n     *\n     * @param {?} notificationId ID of the notification to dismiss\n     * @return {?}\n     */\n        function (notificationId) {\n            this.queueService.push({\n                payload: notificationId,\n                type: 'HIDE'\n            });\n        };\n    /**\n     * Event handler, handles notification ready events\n     *\n     * @param {?} notificationComponent Notification component reference\n     * @return {?}\n     */\n    NotifierContainerComponent.prototype.onNotificationReady = /**\n     * Event handler, handles notification ready events\n     *\n     * @param {?} notificationComponent Notification component reference\n     * @return {?}\n     */\n        function (notificationComponent) {\n            var /** @type {?} */ currentNotification = this.notifications[this.notifications.length - 1]; // Get the latest notification\n            currentNotification.component = notificationComponent; // Save the new omponent reference\n            this.continueHandleShowAction(currentNotification); // Continue with handling the show action\n        };\n    /**\n     * Handle incoming actions by mapping action types to methods, and then running them\n     *\n     * @param {?} action Action object\n     * @return {?} Promise, resolved when done\n     */\n    NotifierContainerComponent.prototype.handleAction = /**\n     * Handle incoming actions by mapping action types to methods, and then running them\n     *\n     * @param {?} action Action object\n     * @return {?} Promise, resolved when done\n     */\n        function (action) {\n            switch (action.type) {\n                // TODO: Maybe a map (actionType -> class method) is a cleaner solution here?\n                case 'SHOW':\n                    return this.handleShowAction(action);\n                case 'HIDE':\n                    return this.handleHideAction(action);\n                case 'HIDE_OLDEST':\n                    return this.handleHideOldestAction(action);\n                case 'HIDE_NEWEST':\n                    return this.handleHideNewestAction(action);\n                case 'HIDE_ALL':\n                    return this.handleHideAllAction(action);\n                default:\n                    return new Promise(function (resolve, reject) {\n                        resolve(); // Ignore unknown action types\n                    });\n            }\n        };\n    /**\n     * Show a new notification\n     *\n     * We simply add the notification to the list, and then wait until its properly initialized / created / rendered.\n     *\n     * @param {?} action Action object\n     * @return {?} Promise, resolved when done\n     */\n    NotifierContainerComponent.prototype.handleShowAction = /**\n     * Show a new notification\n     *\n     * We simply add the notification to the list, and then wait until its properly initialized / created / rendered.\n     *\n     * @param {?} action Action object\n     * @return {?} Promise, resolved when done\n     */\n        function (action) {\n            var _this = this;\n            return new Promise(function (resolve, reject) {\n                _this.tempPromiseResolver = resolve; // Save the promise resolve function so that it can be called later on by another method\n                _this.addNotificationToList(new NotifierNotification(action.payload));\n            });\n        };\n    /**\n     * Continue to show a new notification (after the notification components is initialized / created / rendered).\n     *\n     * If this is the first (and thus only) notification, we can simply show it. Otherwhise, if stacking is disabled (or a low value), we\n     * switch out notifications, in particular we hide the existing one, and then show our new one. Yet, if stacking is enabled, we first\n     * shift all older notifications, and then show our new notification. In addition, if there are too many notification on the screen,\n     * we hide the oldest one first. Furthermore, if configured, animation overlapping is applied.\n     *\n     * @param {?} notification New notification to show\n     * @return {?}\n     */\n    NotifierContainerComponent.prototype.continueHandleShowAction = /**\n     * Continue to show a new notification (after the notification components is initialized / created / rendered).\n     *\n     * If this is the first (and thus only) notification, we can simply show it. Otherwhise, if stacking is disabled (or a low value), we\n     * switch out notifications, in particular we hide the existing one, and then show our new one. Yet, if stacking is enabled, we first\n     * shift all older notifications, and then show our new notification. In addition, if there are too many notification on the screen,\n     * we hide the oldest one first. Furthermore, if configured, animation overlapping is applied.\n     *\n     * @param {?} notification New notification to show\n     * @return {?}\n     */\n        function (notification) {\n            var _this = this;\n            // First (which means only one) notification in the list?\n            var /** @type {?} */ numberOfNotifications = this.notifications.length;\n            if (numberOfNotifications === 1) {\n                notification.component.show().then(this.tempPromiseResolver); // Done\n            }\n            else {\n                var /** @type {?} */ implicitStackingLimit = 2;\n                // Stacking enabled? (stacking value below 2 means stacking is disabled)\n                if (this.config.behaviour.stacking === false || this.config.behaviour.stacking < implicitStackingLimit) {\n                    this.notifications[0].component.hide().then(function () {\n                        _this.removeNotificationFromList(_this.notifications[0]);\n                        notification.component.show().then(_this.tempPromiseResolver); // Done\n                    });\n                }\n                else {\n                    var /** @type {?} */ stepPromises_1 = [];\n                    // Are there now too many notifications?\n                    if (numberOfNotifications > this.config.behaviour.stacking) {\n                        var /** @type {?} */ oldNotifications_1 = this.notifications.slice(1, numberOfNotifications - 1);\n                        // Are animations enabled?\n                        if (this.config.animations.enabled) {\n                            // Is animation overlap enabled?\n                            if (this.config.animations.overlap !== false && this.config.animations.overlap > 0) {\n                                stepPromises_1.push(this.notifications[0].component.hide());\n                                setTimeout(function () {\n                                    stepPromises_1.push(_this.shiftNotifications(oldNotifications_1, notification.component.getHeight(), true));\n                                }, this.config.animations.hide.speed - this.config.animations.overlap);\n                                setTimeout(function () {\n                                    stepPromises_1.push(notification.component.show());\n                                }, this.config.animations.hide.speed + this.config.animations.shift.speed - this.config.animations.overlap);\n                            }\n                            else {\n                                stepPromises_1.push(new Promise(function (resolve, reject) {\n                                    _this.notifications[0].component.hide().then(function () {\n                                        _this.shiftNotifications(oldNotifications_1, notification.component.getHeight(), true).then(function () {\n                                            notification.component.show().then(resolve);\n                                        });\n                                    });\n                                }));\n                            }\n                        }\n                        else {\n                            stepPromises_1.push(this.notifications[0].component.hide());\n                            stepPromises_1.push(this.shiftNotifications(oldNotifications_1, notification.component.getHeight(), true));\n                            stepPromises_1.push(notification.component.show());\n                        }\n                    }\n                    else {\n                        var /** @type {?} */ oldNotifications_2 = this.notifications.slice(0, numberOfNotifications - 1);\n                        // Are animations enabled?\n                        if (this.config.animations.enabled) {\n                            // Is animation overlap enabled?\n                            if (this.config.animations.overlap !== false && this.config.animations.overlap > 0) {\n                                stepPromises_1.push(this.shiftNotifications(oldNotifications_2, notification.component.getHeight(), true));\n                                setTimeout(function () {\n                                    stepPromises_1.push(notification.component.show());\n                                }, this.config.animations.shift.speed - this.config.animations.overlap);\n                            }\n                            else {\n                                stepPromises_1.push(new Promise(function (resolve, reject) {\n                                    _this.shiftNotifications(oldNotifications_2, notification.component.getHeight(), true).then(function () {\n                                        notification.component.show().then(resolve);\n                                    });\n                                }));\n                            }\n                        }\n                        else {\n                            stepPromises_1.push(this.shiftNotifications(oldNotifications_2, notification.component.getHeight(), true));\n                            stepPromises_1.push(notification.component.show());\n                        }\n                    }\n                    Promise.all(stepPromises_1).then(function () {\n                        if (numberOfNotifications > _this.config.behaviour.stacking) {\n                            _this.removeNotificationFromList(_this.notifications[0]);\n                        }\n                        _this.tempPromiseResolver();\n                    }); // Done\n                }\n            }\n        };\n    /**\n     * Hide an existing notification\n     *\n     * Fist, we skip everything if there are no notifications at all, or the given notification does not exist. Then, we hide the given\n     * notification. If there exist older notifications, we then shift them around to fill the gap. Once both hiding the given notification\n     * and shifting the older notificaitons is done, the given notification gets finally removed (from the DOM).\n     *\n     * @param {?} action Action object, payload contains the notification ID\n     * @return {?} Promise, resolved when done\n     */\n    NotifierContainerComponent.prototype.handleHideAction = /**\n     * Hide an existing notification\n     *\n     * Fist, we skip everything if there are no notifications at all, or the given notification does not exist. Then, we hide the given\n     * notification. If there exist older notifications, we then shift them around to fill the gap. Once both hiding the given notification\n     * and shifting the older notificaitons is done, the given notification gets finally removed (from the DOM).\n     *\n     * @param {?} action Action object, payload contains the notification ID\n     * @return {?} Promise, resolved when done\n     */\n        function (action) {\n            var _this = this;\n            return new Promise(function (resolve, reject) {\n                var /** @type {?} */ stepPromises = [];\n                // Does the notification exist / are there even any notifications? (let's prevent accidential errors)\n                var /** @type {?} */ notification = _this.findNotificationById(action.payload);\n                if (notification === undefined) {\n                    resolve();\n                    return;\n                }\n                // Get older notifications\n                var /** @type {?} */ notificationIndex = _this.findNotificationIndexById(action.payload);\n                if (notificationIndex === undefined) {\n                    resolve();\n                    return;\n                }\n                var /** @type {?} */ oldNotifications = _this.notifications.slice(0, notificationIndex);\n                // Do older notifications exist, and thus do we need to shift other notifications as a consequence?\n                if (oldNotifications.length > 0) {\n                    // Are animations enabled?\n                    if (_this.config.animations.enabled && _this.config.animations.hide.speed > 0) {\n                        // Is animation overlap enabled?\n                        if (_this.config.animations.overlap !== false && _this.config.animations.overlap > 0) {\n                            stepPromises.push(notification.component.hide());\n                            setTimeout(function () {\n                                stepPromises.push(_this.shiftNotifications(oldNotifications, notification.component.getHeight(), false));\n                            }, _this.config.animations.hide.speed - _this.config.animations.overlap);\n                        }\n                        else {\n                            notification.component.hide().then(function () {\n                                stepPromises.push(_this.shiftNotifications(oldNotifications, notification.component.getHeight(), false));\n                            });\n                        }\n                    }\n                    else {\n                        stepPromises.push(notification.component.hide());\n                        stepPromises.push(_this.shiftNotifications(oldNotifications, notification.component.getHeight(), false));\n                    }\n                }\n                else {\n                    stepPromises.push(notification.component.hide());\n                }\n                // Wait until both hiding and shifting is done, then remove the notification from the list\n                Promise.all(stepPromises).then(function () {\n                    _this.removeNotificationFromList(notification);\n                    resolve(); // Done\n                });\n            });\n        };\n    /**\n     * Hide the oldest notification (bridge to handleHideAction)\n     *\n     * @param {?} action Action object\n     * @return {?} Promise, resolved when done\n     */\n    NotifierContainerComponent.prototype.handleHideOldestAction = /**\n     * Hide the oldest notification (bridge to handleHideAction)\n     *\n     * @param {?} action Action object\n     * @return {?} Promise, resolved when done\n     */\n        function (action) {\n            // Are there any notifications? (prevent accidential errors)\n            if (this.notifications.length === 0) {\n                return new Promise(function (resolve, reject) {\n                    resolve();\n                }); // Done\n            }\n            else {\n                action.payload = this.notifications[0].id;\n                return this.handleHideAction(action);\n            }\n        };\n    /**\n     * Hide the newest notification (bridge to handleHideAction)\n     *\n     * @param {?} action Action object\n     * @return {?} Promise, resolved when done\n     */\n    NotifierContainerComponent.prototype.handleHideNewestAction = /**\n     * Hide the newest notification (bridge to handleHideAction)\n     *\n     * @param {?} action Action object\n     * @return {?} Promise, resolved when done\n     */\n        function (action) {\n            // Are there any notifications? (prevent accidential errors)\n            if (this.notifications.length === 0) {\n                return new Promise(function (resolve, reject) {\n                    resolve();\n                }); // Done\n            }\n            else {\n                action.payload = this.notifications[this.notifications.length - 1].id;\n                return this.handleHideAction(action);\n            }\n        };\n    /**\n     * Hide all notifications at once\n     *\n     * @param {?} action Action object\n     * @return {?} Promise, resolved when done\n     */\n    NotifierContainerComponent.prototype.handleHideAllAction = /**\n     * Hide all notifications at once\n     *\n     * @param {?} action Action object\n     * @return {?} Promise, resolved when done\n     */\n        function (action) {\n            var _this = this;\n            return new Promise(function (resolve, reject) {\n                // Are there any notifications? (prevent accidential errors)\n                var /** @type {?} */ numberOfNotifications = _this.notifications.length;\n                if (numberOfNotifications === 0) {\n                    resolve(); // Done\n                    return;\n                }\n                // Are animations enabled?\n                if (_this.config.animations.enabled && _this.config.animations.hide.speed > 0 && _this.config.animations.hide.offset !== false &&\n                    _this.config.animations.hide.offset > 0) {\n                    var _loop_1 = function (i) {\n                        var /** @type {?} */ animationOffset = _this.config.position.vertical.position === 'top' ? numberOfNotifications - 1 : i;\n                        setTimeout(function () {\n                            _this.notifications[i].component.hide().then(function () {\n                                // Are we done here, was this the last notification to be hidden?\n                                if ((_this.config.position.vertical.position === 'top' && i === 0) ||\n                                    (_this.config.position.vertical.position === 'bottom' && i === numberOfNotifications - 1)) {\n                                    _this.removeAllNotificationsFromList();\n                                    resolve(); // Done\n                                }\n                            });\n                        }, _this.config.animations.hide.offset * animationOffset);\n                    };\n                    for (var /** @type {?} */ i = numberOfNotifications - 1; i >= 0; i--) {\n                        _loop_1(i);\n                    }\n                }\n                else {\n                    var /** @type {?} */ stepPromises = [];\n                    for (var /** @type {?} */ i = numberOfNotifications - 1; i >= 0; i--) {\n                        stepPromises.push(_this.notifications[i].component.hide());\n                    }\n                    Promise.all(stepPromises).then(function () {\n                        _this.removeAllNotificationsFromList();\n                        resolve(); // Done\n                    });\n                }\n            });\n        };\n    /**\n     * Shift multiple notifications at once\n     *\n     * @param {?} notifications List containing the notifications to be shifted\n     * @param {?} distance      Distance to shift (in px)\n     * @param {?} toMakePlace   Flag, defining in which direciton to shift\n     * @return {?} Promise, resolved when done\n     */\n    NotifierContainerComponent.prototype.shiftNotifications = /**\n     * Shift multiple notifications at once\n     *\n     * @param {?} notifications List containing the notifications to be shifted\n     * @param {?} distance      Distance to shift (in px)\n     * @param {?} toMakePlace   Flag, defining in which direciton to shift\n     * @return {?} Promise, resolved when done\n     */\n        function (notifications, distance, toMakePlace) {\n            return new Promise(function (resolve, reject) {\n                // Are there any notifications to shift?\n                if (notifications.length === 0) {\n                    resolve();\n                    return;\n                }\n                var /** @type {?} */ notificationPromises = [];\n                for (var /** @type {?} */ i = notifications.length - 1; i >= 0; i--) {\n                    notificationPromises.push(notifications[i].component.shift(distance, toMakePlace));\n                }\n                Promise.all(notificationPromises).then(resolve); // Done\n            });\n        };\n    /**\n     * Add a new notification to the list of notifications (triggers change detection)\n     *\n     * @param {?} notification Notification to add to the list of notifications\n     * @return {?}\n     */\n    NotifierContainerComponent.prototype.addNotificationToList = /**\n     * Add a new notification to the list of notifications (triggers change detection)\n     *\n     * @param {?} notification Notification to add to the list of notifications\n     * @return {?}\n     */\n        function (notification) {\n            this.notifications.push(notification);\n            this.changeDetector.markForCheck(); // Run change detection because the notification list changed\n        };\n    /**\n     * Remove an existing notification from the list of notifications (triggers change detection)\n     *\n     * @param {?} notification Notification to be removed from the list of notifications\n     * @return {?}\n     */\n    NotifierContainerComponent.prototype.removeNotificationFromList = /**\n     * Remove an existing notification from the list of notifications (triggers change detection)\n     *\n     * @param {?} notification Notification to be removed from the list of notifications\n     * @return {?}\n     */\n        function (notification) {\n            this.notifications =\n                this.notifications.filter(function (item) { return item.component !== notification.component; });\n            this.changeDetector.markForCheck(); // Run change detection because the notification list changed\n        };\n    /**\n     * Remove all notifications from the list (triggers change detection)\n     * @return {?}\n     */\n    NotifierContainerComponent.prototype.removeAllNotificationsFromList = /**\n     * Remove all notifications from the list (triggers change detection)\n     * @return {?}\n     */\n        function () {\n            this.notifications = [];\n            this.changeDetector.markForCheck(); // Run change detection because the notification list changed\n        };\n    /**\n     * Helper: Find a notification in the notification list by a given notification ID\n     *\n     * @param {?} notificationId Notification ID, used for finding notification\n     * @return {?} Notification, undefined if not found\n     */\n    NotifierContainerComponent.prototype.findNotificationById = /**\n     * Helper: Find a notification in the notification list by a given notification ID\n     *\n     * @param {?} notificationId Notification ID, used for finding notification\n     * @return {?} Notification, undefined if not found\n     */\n        function (notificationId) {\n            return this.notifications.find(function (currentNotification) { return currentNotification.id === notificationId; });\n        };\n    /**\n     * Helper: Find a notification's index by a given notification ID\n     *\n     * @param {?} notificationId Notification ID, used for finding a notification's index\n     * @return {?} Notification index, undefined if not found\n     */\n    NotifierContainerComponent.prototype.findNotificationIndexById = /**\n     * Helper: Find a notification's index by a given notification ID\n     *\n     * @param {?} notificationId Notification ID, used for finding a notification's index\n     * @return {?} Notification index, undefined if not found\n     */\n        function (notificationId) {\n            var /** @type {?} */ notificationIndex = this.notifications.findIndex(function (currentNotification) { return currentNotification.id === notificationId; });\n            return (notificationIndex !== -1 ? notificationIndex : undefined);\n        };\n    return NotifierContainerComponent;\n}());\nexport { NotifierContainerComponent };\nfunction NotifierContainerComponent_tsickle_Closure_declarations() {\n    /**\n     * List of currently somewhat active notifications\n     * @type {?}\n     */\n    NotifierContainerComponent.prototype.notifications;\n    /**\n     * Change detector\n     * @type {?}\n     */\n    NotifierContainerComponent.prototype.changeDetector;\n    /**\n     * Notifier queue service\n     * @type {?}\n     */\n    NotifierContainerComponent.prototype.queueService;\n    /**\n     * Notifier configuration\n     * @type {?}\n     */\n    NotifierContainerComponent.prototype.config;\n    /**\n     * Queue service observable subscription (saved for cleanup)\n     * @type {?}\n     */\n    NotifierContainerComponent.prototype.queueServiceSubscription;\n    /**\n     * Promise resolve function reference, temporarily used while the notification child component gets created\n     * @type {?}\n     */\n    NotifierContainerComponent.prototype.tempPromiseResolver;\n}\n//# sourceMappingURL=notifier-container.component.js.map\n",null]}