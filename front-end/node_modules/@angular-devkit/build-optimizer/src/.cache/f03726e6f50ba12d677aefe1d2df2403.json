{"remainingRequest":"/home/skan/program/gitLab/materialDidactico/front-end/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--8-1!/home/skan/program/gitLab/materialDidactico/front-end/node_modules/angular-notifier/esm5/src/components/notifier-notification.component.js","dependencies":[{"path":"/home/skan/program/gitLab/materialDidactico/front-end/node_modules/angular-notifier/esm5/src/components/notifier-notification.component.js","mtime":499162500000},{"path":"/home/skan/program/gitLab/materialDidactico/front-end/node_modules/cache-loader/dist/cjs.js","mtime":1540859967560},{"path":"/home/skan/program/gitLab/materialDidactico/front-end/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1528256844000}],"contextDependencies":[],"result":["/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nimport { ChangeDetectionStrategy, Component, ElementRef, EventEmitter, Input, Output, Renderer2 } from '@angular/core';\nimport { NotifierAnimationService } from './../services/notifier-animation.service';\nimport { NotifierService } from './../services/notifier.service';\nimport { NotifierTimerService } from './../services/notifier-timer.service';\n/**\n * Notifier notification component\n * -------------------------------\n * This component is responsible for actually displaying the notification on screen. In addition, it's able to show and hide this\n * notification, in particular to animate this notification in and out, as well as shift (move) this notification vertically around.\n * Furthermore, the notification component handles all interactions the user has with this notification / component, such as clicks and\n * mouse movements.\n */\nvar NotifierNotificationComponent = /** @class */ /*@__PURE__*/ (function () {\n    function NotifierNotificationComponent(elementRef, renderer, notifierService, notifierTimerService, notifierAnimationService) {\n        this.config = notifierService.getConfig();\n        this.ready = new EventEmitter();\n        this.dismiss = new EventEmitter();\n        this.timerService = notifierTimerService;\n        this.animationService = notifierAnimationService;\n        this.renderer = renderer;\n        this.element = elementRef.nativeElement;\n        this.elementShift = 0;\n    }\n    /**\n     * Component after view init lifecycle hook, setts up the component and then emits the ready event\n     * @return {?}\n     */\n    NotifierNotificationComponent.prototype.ngAfterViewInit = /**\n     * Component after view init lifecycle hook, setts up the component and then emits the ready event\n     * @return {?}\n     */\n        function () {\n            this.setup();\n            this.elementHeight = this.element.offsetHeight;\n            this.elementWidth = this.element.offsetWidth;\n            this.ready.emit(this);\n        };\n    /**\n     * Get the notifier config\n     *\n     * @return {?} Notifier configuration\n     */\n    NotifierNotificationComponent.prototype.getConfig = /**\n     * Get the notifier config\n     *\n     * @return {?} Notifier configuration\n     */\n        function () {\n            return this.config;\n        };\n    /**\n     * Get notification element height (in px)\n     *\n     * @return {?} Notification element height (in px)\n     */\n    NotifierNotificationComponent.prototype.getHeight = /**\n     * Get notification element height (in px)\n     *\n     * @return {?} Notification element height (in px)\n     */\n        function () {\n            return this.elementHeight;\n        };\n    /**\n     * Get notification element width (in px)\n     *\n     * @return {?} Notification element height (in px)\n     */\n    NotifierNotificationComponent.prototype.getWidth = /**\n     * Get notification element width (in px)\n     *\n     * @return {?} Notification element height (in px)\n     */\n        function () {\n            return this.elementWidth;\n        };\n    /**\n     * Get notification shift offset (in px)\n     *\n     * @return {?} Notification element shift offset (in px)\n     */\n    NotifierNotificationComponent.prototype.getShift = /**\n     * Get notification shift offset (in px)\n     *\n     * @return {?} Notification element shift offset (in px)\n     */\n        function () {\n            return this.elementShift;\n        };\n    /**\n     * Show (animate in) this notification\n     *\n     * @return {?} Promise, resolved when done\n     */\n    NotifierNotificationComponent.prototype.show = /**\n     * Show (animate in) this notification\n     *\n     * @return {?} Promise, resolved when done\n     */\n        function () {\n            var _this = this;\n            return new Promise(function (resolve, reject) {\n                // Are animations enabled?\n                if (_this.config.animations.enabled && _this.config.animations.show.speed > 0) {\n                    // Get animation data\n                    var /** @type {?} */ animationData = _this.animationService.getAnimationData('show', _this.notification);\n                    // Set initial styles (styles before animation), prevents quick flicker when animation starts\n                    var /** @type {?} */ animatedProperties = Object.keys(animationData.keyframes[0]);\n                    for (var /** @type {?} */ i = animatedProperties.length - 1; i >= 0; i--) {\n                        _this.renderer.setStyle(_this.element, animatedProperties[i], animationData.keyframes[0][animatedProperties[i]]);\n                    }\n                    // Animate notification in\n                    // Animate notification in\n                    _this.renderer.setStyle(_this.element, 'visibility', 'visible');\n                    var /** @type {?} */ animation = _this.element.animate(animationData.keyframes, animationData.options);\n                    animation.onfinish = function () {\n                        _this.startAutoHideTimer();\n                        resolve(); // Done\n                    };\n                }\n                else {\n                    // Show notification\n                    // Show notification\n                    _this.renderer.setStyle(_this.element, 'visibility', 'visible');\n                    _this.startAutoHideTimer();\n                    resolve(); // Done\n                }\n            });\n        };\n    /**\n     * Hide (animate out) this notification\n     *\n     * @return {?} Promise, resolved when done\n     */\n    NotifierNotificationComponent.prototype.hide = /**\n     * Hide (animate out) this notification\n     *\n     * @return {?} Promise, resolved when done\n     */\n        function () {\n            var _this = this;\n            return new Promise(function (resolve, reject) {\n                _this.stopAutoHideTimer();\n                // Are animations enabled?\n                if (_this.config.animations.enabled && _this.config.animations.hide.speed > 0) {\n                    var /** @type {?} */ animationData = _this.animationService.getAnimationData('hide', _this.notification);\n                    var /** @type {?} */ animation = _this.element.animate(animationData.keyframes, animationData.options);\n                    animation.onfinish = function () {\n                        resolve(); // Done\n                    };\n                }\n                else {\n                    resolve(); // Done\n                }\n            });\n        };\n    /**\n     * Shift (move) this notification\n     *\n     * @param {?} distance         Distance to shift (in px)\n     * @param {?} shiftToMakePlace Flag, defining in which direction to shift\n     * @return {?} Promise, resolved when done\n     */\n    NotifierNotificationComponent.prototype.shift = /**\n     * Shift (move) this notification\n     *\n     * @param {?} distance         Distance to shift (in px)\n     * @param {?} shiftToMakePlace Flag, defining in which direction to shift\n     * @return {?} Promise, resolved when done\n     */\n        function (distance, shiftToMakePlace) {\n            var _this = this;\n            return new Promise(function (resolve, reject) {\n                // Calculate new position (position after the shift)\n                var /** @type {?} */ newElementShift;\n                if ((_this.config.position.vertical.position === 'top' && shiftToMakePlace)\n                    || (_this.config.position.vertical.position === 'bottom' && !shiftToMakePlace)) {\n                    newElementShift = _this.elementShift + distance + _this.config.position.vertical.gap;\n                }\n                else {\n                    newElementShift = _this.elementShift - distance - _this.config.position.vertical.gap;\n                }\n                var /** @type {?} */ horizontalPosition = _this.config.position.horizontal.position === 'middle' ? '-50%' : '0';\n                // Are animations enabled?\n                if (_this.config.animations.enabled && _this.config.animations.shift.speed > 0) {\n                    var /** @type {?} */ animationData = {\n                        // TODO: Extract into animation service\n                        keyframes: [\n                            {\n                                transform: \"translate3d( \" + horizontalPosition + \", \" + _this.elementShift + \"px, 0 )\"\n                            },\n                            {\n                                transform: \"translate3d( \" + horizontalPosition + \", \" + newElementShift + \"px, 0 )\"\n                            }\n                        ],\n                        options: {\n                            duration: _this.config.animations.shift.speed,\n                            easing: _this.config.animations.shift.easing,\n                            fill: 'forwards'\n                        }\n                    };\n                    _this.elementShift = newElementShift;\n                    var /** @type {?} */ animation = _this.element.animate(animationData.keyframes, animationData.options);\n                    animation.onfinish = function () {\n                        resolve(); // Done\n                    };\n                }\n                else {\n                    _this.renderer.setStyle(_this.element, 'transform', \"translate3d( \" + horizontalPosition + \", \" + newElementShift + \"px, 0 )\");\n                    _this.elementShift = newElementShift;\n                    resolve(); // Done\n                }\n            });\n        };\n    /**\n     * Handle click on dismiss button\n     * @return {?}\n     */\n    NotifierNotificationComponent.prototype.onClickDismiss = /**\n     * Handle click on dismiss button\n     * @return {?}\n     */\n        function () {\n            this.dismiss.emit(this.notification.id);\n        };\n    /**\n     * Handle mouseover over notification area\n     * @return {?}\n     */\n    NotifierNotificationComponent.prototype.onNotificationMouseover = /**\n     * Handle mouseover over notification area\n     * @return {?}\n     */\n        function () {\n            if (this.config.behaviour.onMouseover === 'pauseAutoHide') {\n                this.pauseAutoHideTimer();\n            }\n            else if (this.config.behaviour.onMouseover === 'resetAutoHide') {\n                this.stopAutoHideTimer();\n            }\n        };\n    /**\n     * Handle mouseout from notification area\n     * @return {?}\n     */\n    NotifierNotificationComponent.prototype.onNotificationMouseout = /**\n     * Handle mouseout from notification area\n     * @return {?}\n     */\n        function () {\n            if (this.config.behaviour.onMouseover === 'pauseAutoHide') {\n                this.continueAutoHideTimer();\n            }\n            else if (this.config.behaviour.onMouseover === 'resetAutoHide') {\n                this.startAutoHideTimer();\n            }\n        };\n    /**\n     * Handle click on notification area\n     * @return {?}\n     */\n    NotifierNotificationComponent.prototype.onNotificationClick = /**\n     * Handle click on notification area\n     * @return {?}\n     */\n        function () {\n            if (this.config.behaviour.onClick === 'hide') {\n                this.onClickDismiss();\n            }\n        };\n    /**\n     * Start the auto hide timer (if enabled)\n     * @return {?}\n     */\n    NotifierNotificationComponent.prototype.startAutoHideTimer = /**\n     * Start the auto hide timer (if enabled)\n     * @return {?}\n     */\n        function () {\n            var _this = this;\n            if (this.config.behaviour.autoHide !== false && this.config.behaviour.autoHide > 0) {\n                this.timerService.start(this.config.behaviour.autoHide).then(function () {\n                    _this.onClickDismiss();\n                });\n            }\n        };\n    /**\n     * Pause the auto hide timer (if enabled)\n     * @return {?}\n     */\n    NotifierNotificationComponent.prototype.pauseAutoHideTimer = /**\n     * Pause the auto hide timer (if enabled)\n     * @return {?}\n     */\n        function () {\n            if (this.config.behaviour.autoHide !== false && this.config.behaviour.autoHide > 0) {\n                this.timerService.pause();\n            }\n        };\n    /**\n     * Continue the auto hide timer (if enabled)\n     * @return {?}\n     */\n    NotifierNotificationComponent.prototype.continueAutoHideTimer = /**\n     * Continue the auto hide timer (if enabled)\n     * @return {?}\n     */\n        function () {\n            if (this.config.behaviour.autoHide !== false && this.config.behaviour.autoHide > 0) {\n                this.timerService.continue();\n            }\n        };\n    /**\n     * Stop the auto hide timer (if enabled)\n     * @return {?}\n     */\n    NotifierNotificationComponent.prototype.stopAutoHideTimer = /**\n     * Stop the auto hide timer (if enabled)\n     * @return {?}\n     */\n        function () {\n            if (this.config.behaviour.autoHide !== false && this.config.behaviour.autoHide > 0) {\n                this.timerService.stop();\n            }\n        };\n    /**\n     * Initial notification setup\n     * @return {?}\n     */\n    NotifierNotificationComponent.prototype.setup = /**\n     * Initial notification setup\n     * @return {?}\n     */\n        function () {\n            // Set start position (initially the exact same for every new notification)\n            if (this.config.position.horizontal.position === 'left') {\n                this.renderer.setStyle(this.element, 'left', this.config.position.horizontal.distance + \"px\");\n            }\n            else if (this.config.position.horizontal.position === 'right') {\n                this.renderer.setStyle(this.element, 'right', this.config.position.horizontal.distance + \"px\");\n            }\n            else {\n                this.renderer.setStyle(this.element, 'left', '50%');\n                // Let's get the GPU handle some work as well (#perfmatters)\n                this.renderer.setStyle(this.element, 'transform', 'translate3d( -50%, 0, 0 )');\n            }\n            if (this.config.position.vertical.position === 'top') {\n                this.renderer.setStyle(this.element, 'top', this.config.position.vertical.distance + \"px\");\n            }\n            else {\n                this.renderer.setStyle(this.element, 'bottom', this.config.position.vertical.distance + \"px\");\n            }\n            // Add classes (responsible for visual design)\n            this.renderer.addClass(this.element, \"notifier__notification--\" + this.notification.type);\n            this.renderer.addClass(this.element, \"notifier__notification--\" + this.config.theme);\n        };\n    return NotifierNotificationComponent;\n}());\nexport { NotifierNotificationComponent };\nfunction NotifierNotificationComponent_tsickle_Closure_declarations() {\n    /**\n     * Input: Notification object, contains all details necessary to construct the notification\n     * @type {?}\n     */\n    NotifierNotificationComponent.prototype.notification;\n    /**\n     * Output: Ready event, handles the initialization success by emitting a reference to this notification component\n     * @type {?}\n     */\n    NotifierNotificationComponent.prototype.ready;\n    /**\n     * Output: Dismiss event, handles the click on the dismiss button by emitting the notification ID of this notification component\n     * @type {?}\n     */\n    NotifierNotificationComponent.prototype.dismiss;\n    /**\n     * Notifier configuration\n     * @type {?}\n     */\n    NotifierNotificationComponent.prototype.config;\n    /**\n     * Notifier timer service\n     * @type {?}\n     */\n    NotifierNotificationComponent.prototype.timerService;\n    /**\n     * Notifier animation service\n     * @type {?}\n     */\n    NotifierNotificationComponent.prototype.animationService;\n    /**\n     * Angular renderer, used to preserve the overall DOM abstraction & independence\n     * @type {?}\n     */\n    NotifierNotificationComponent.prototype.renderer;\n    /**\n     * Native element reference, used for manipulating DOM properties\n     * @type {?}\n     */\n    NotifierNotificationComponent.prototype.element;\n    /**\n     * Current notification height, calculated and cached here (#perfmatters)\n     * @type {?}\n     */\n    NotifierNotificationComponent.prototype.elementHeight;\n    /**\n     * Current notification width, calculated and cached here (#perfmatters)\n     * @type {?}\n     */\n    NotifierNotificationComponent.prototype.elementWidth;\n    /**\n     * Current notification shift, calculated and cached here (#perfmatters)\n     * @type {?}\n     */\n    NotifierNotificationComponent.prototype.elementShift;\n}\n//# sourceMappingURL=notifier-notification.component.js.map\n",null]}