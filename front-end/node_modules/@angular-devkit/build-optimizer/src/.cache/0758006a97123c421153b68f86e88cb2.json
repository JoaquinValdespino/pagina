{"remainingRequest":"/home/skan/program/gitLab/materialDidactico/front-end/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--8-1!/home/skan/program/gitLab/materialDidactico/front-end/node_modules/angular-notifier/esm5/src/services/notifier-queue.service.js","dependencies":[{"path":"/home/skan/program/gitLab/materialDidactico/front-end/node_modules/angular-notifier/esm5/src/services/notifier-queue.service.js","mtime":499162500000},{"path":"/home/skan/program/gitLab/materialDidactico/front-end/node_modules/cache-loader/dist/cjs.js","mtime":1540859967560},{"path":"/home/skan/program/gitLab/materialDidactico/front-end/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1528256844000}],"contextDependencies":[],"result":["/**\n * @fileoverview added by tsickle\n * @suppress {checkTypes} checked by tsc\n */\nimport { Injectable } from '@angular/core';\nimport { Subject } from 'rxjs';\n/**\n * Notifier queue service\n *\n * In general, API calls don't get processed right away. Instead, we have to queue them up in order to prevent simultanious API calls\n * interfering with each other. This, at least in theory, is possible at any time. In particular, animations - which potentially overlap -\n * can cause changes in JS classes as well as affect the DOM. Therefore, the queue service takes all actions, puts them in a queue, and\n * processes them at the right time (which is when the previous action has been processed successfully).\n *\n * Technical sidenote:\n * An action looks pretty similar to the ones within the Flux / Redux pattern.\n */\nvar NotifierQueueService = /** @class */ /*@__PURE__*/ (function () {\n    function NotifierQueueService() {\n        this.actionStream = new Subject();\n        this.actionQueue = [];\n        this.isActionInProgress = false;\n    }\n    /**\n     * Push a new action to the queue, and try to run it\n     *\n     * @param {?} action Action object\n     * @return {?}\n     */\n    NotifierQueueService.prototype.push = /**\n     * Push a new action to the queue, and try to run it\n     *\n     * @param {?} action Action object\n     * @return {?}\n     */\n        function (action) {\n            this.actionQueue.push(action);\n            this.tryToRunNextAction();\n        };\n    /**\n     * Continue with the next action (called when the current action is finished)\n     * @return {?}\n     */\n    NotifierQueueService.prototype.continue = /**\n     * Continue with the next action (called when the current action is finished)\n     * @return {?}\n     */\n        function () {\n            this.isActionInProgress = false;\n            this.tryToRunNextAction();\n        };\n    /**\n     * Try to run the next action in the queue; we skip if there already is some action in progress, or if there is no action left\n     * @return {?}\n     */\n    NotifierQueueService.prototype.tryToRunNextAction = /**\n     * Try to run the next action in the queue; we skip if there already is some action in progress, or if there is no action left\n     * @return {?}\n     */\n        function () {\n            if (this.isActionInProgress || this.actionQueue.length === 0) {\n                return; // Skip (the queue can now go drink a coffee as it has nothing to do anymore)\n            }\n            this.isActionInProgress = true;\n            this.actionStream.next(this.actionQueue.shift()); // Push next action to the stream, and remove the current action from the queue\n        };\n    return NotifierQueueService;\n}());\nexport { NotifierQueueService };\nfunction NotifierQueueService_tsickle_Closure_declarations() {\n    /**\n     * Stream of actions, subscribable from outside\n     * @type {?}\n     */\n    NotifierQueueService.prototype.actionStream;\n    /**\n     * Queue of actions\n     * @type {?}\n     */\n    NotifierQueueService.prototype.actionQueue;\n    /**\n     * Flag, true if some action is currently in progress\n     * @type {?}\n     */\n    NotifierQueueService.prototype.isActionInProgress;\n}\n//# sourceMappingURL=notifier-queue.service.js.map\n",null]}